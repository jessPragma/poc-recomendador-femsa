import { NgClass } from '@angular/common';
import {
	AfterViewInit,
	Component,
	ElementRef,
	EventEmitter,
	inject,
	OnDestroy,
	OnInit,
	Output,
	ViewChild
} from '@angular/core';
import { DomSanitizer, SafeHtml } from '@angular/platform-browser';
import { QuestionRequest, Request } from '@core/interfaces/question.interface';
import { UserBankia } from '@core/interfaces/user-bankia.interface';
import { AgentService } from '@core/services/agent/agent.service';
import { QuestionService } from '@core/services/question/question.service';
import { TextService } from '@core/services/text/text.service';
import { UserService } from '@core/services/user/user.service';
import { WsAgentService } from '@core/services/wsAgent/ws-agent.service';
import { ACustomInputTextComponent } from '@ui/atoms/a-custom-input-text/a-custom-input-text.component';
import { AtomsModule } from '@ui/atoms/atoms.module';
import { Observable } from 'rxjs';
import { ACardChatComponent } from '../../atoms/a-card-chat/a-card-chat.component';

@Component({
	selector: 't-modal',
	standalone: true,
	imports: [AtomsModule, NgClass, ACardChatComponent],
	templateUrl: './t-modal.component.html',
	styleUrl: './t-modal.component.scss'
})
export class TModalComponent implements OnInit, AfterViewInit, OnDestroy {
	private readonly wsAgentService = inject(WsAgentService);
	private readonly agentService = inject(AgentService);
	private readonly userService = inject(UserService);
	private readonly questionService = inject(QuestionService);
	private readonly formatTextService = inject(TextService);
	private readonly sanitizer = inject(DomSanitizer);

	user: UserBankia = this.userService.getUser();
	messages$!: Observable<string>; // Observable para los mensajes
	connection = this.wsAgentService.connect(
		'wss://khjsq2bote.execute-api.us-east-1.amazonaws.com/dev/'
	);


	ngOnDestroy(): void {
		this.questionService.setUser({ usuario: '', sessionId: '', password: '' });
		this.wsAgentService.closeConnection();
	}

	ngOnInit(): void {
		this.defaultQuestion = this.questionService.getDefaultQuestions();
		this.listenerWebSocket();
		
		// Exponer el componente para interacción con JavaScript
		(window as any).angularComponentRef = this;
		
		// Inicializar el contador del carrito si hay productos en localStorage
		this.initializeCartBadge();
	}

	chats: { text: SafeHtml; isUser: boolean }[] = [];

	valueInput = '';
	isInputEmpty = false;
	isDisableInput = false;
	isTyping = false; // Bandera para indicar si está "escribiendo"
	welcome = true;
	defaultQuestion: Request[] = [];
	selectedButtonIndex: number = -1; // Índice del botón seleccionado

	@ViewChild('chatContainer') chatContainer!: ElementRef;
	@Output() onclose = new EventEmitter<void>();

	@ViewChild(ACustomInputTextComponent, { static: false })
	inputText!: ACustomInputTextComponent;

	handleClose(): void {
		this.onclose.emit();
	}

	handleInputChanged(value: boolean): void {
		this.isInputEmpty = value;
	}

	handleDebouncedInput(value: string): void {
		this.valueInput = value;
		if (this.valueInput) {
			this.welcome = false;
			this.chats.push({
				text: this.valueInput,
				isUser: true
			});
			this.sendMessageWSocket(this.valueInput);
		}
	}

	sendDefaultQuestion(question: Request, index: number): void {
		if (question.prompt) {
			this.selectedButtonIndex = index;
			this.welcome = false;
			this.valueInput = question.text;
			this.chats.push({
				text: this.valueInput,
				isUser: true
			});
			this.sendMessageWSocket(this.valueInput);
		}
	}

	sendQuestion(): void {
		this.valueInput = this.inputText.currentValue;
		if (this.valueInput.length <= 0) return;
		if (this.valueInput.trim()) {
			this.chats.push({
				text: this.valueInput,
				isUser: true
			});
			this.welcome = false;
		}
		this.inputText.clearInputFrom();
		this.sendMessageWSocket(this.valueInput);
	}

	ngAfterViewInit(): void {
		this.scrollToBottom();
	}

	private scrollToBottom(): void {
		if (this.chatContainer) {
			const container = this.chatContainer.nativeElement;
			if (container) {
				container.scrollTop = container.scrollHeight;
				setTimeout(() => {
					container.scrollTop = container.scrollHeight;
				}, 100);
			}
		}
	}

	sendMessageWSocket(message: string): void {
		this.isInputEmpty = false;
		this.isDisableInput = true;
		this.isTyping = true;
		this.wsAgentService.sendMessage(message);
	}

	tryFocusInput(): void {
		if (!this.inputText.disableInput) {
			this.inputText.resetHeight();
			this.inputText.focusInput();
		} else {
			let attempts = 0;
			const maxAttempts = 5;

			const retryFocus = () => {
				if (attempts < maxAttempts) {
					setTimeout(() => {
						if (!this.inputText.disableInput) {
							this.inputText.resetHeight();
							this.inputText.focusInput();
						} else {
							attempts++;
							retryFocus();
						}
					}, 1000);
				}
			};

			retryFocus();
		}
	}

	private handleWebSocketMessage(
		message: string,
		timeoutDuration: number,
		inactivityTimeout: any
	): void {
		this.reiniciarTemporizador(timeoutDuration, inactivityTimeout);
		this.updateChatList();
		this.updateLastChatMessage(message);
		setTimeout(() => this.scrollToBottom(), 0);
	}

	private updateChatList(): void {
		if (this.chats.length === 0 || this.chats[this.chats.length - 1].isUser) {
			this.chats.push({ isUser: false, text: '' });
			this.isTyping = false;
		}
	}

	private updateLastChatMessage(message: string): void {
		const formattedMessage = this.formatMessageAsList(message);
		const sanitizeMessage = this.sanitizeMessage(formattedMessage);
		this.chats[this.chats.length - 1].text = sanitizeMessage;
	}

	listenerWebSocket(): void {
		console.log('Conexión WebSocket:', this.connection);

		const timeoutDuration = 100;
		let inactivityTimeout: any;

		this.wsAgentService.messages$.subscribe({
			next: (message: string) =>
				this.handleWebSocketMessage(message, timeoutDuration, inactivityTimeout),
			error: (error) => this.handleWebSocketError(error)
		});

		this.reiniciarTemporizador(timeoutDuration, inactivityTimeout);
	}

	private finalizarPorInactividad(): void {
		console.log('No se recibieron mensajes en el tiempo establecido. Finalizando.');
		this.habilitarBotones();
	}

	private reiniciarTemporizador(timeoutDuration: number, inactivityTimeout: any): void {
		if (inactivityTimeout) {
			clearTimeout(inactivityTimeout);
		}
		inactivityTimeout = setTimeout(() => this.finalizarPorInactividad(), timeoutDuration);
	}

	private handleWebSocketError(error: any): void {
		console.error('Error WebSocket:', error);
	}

	habilitarBotones(): void {
		this.isDisableInput = false;
		this.tryFocusInput();
		this.isInputEmpty = true;
	}

	// Variable para seguimiento del carrito
	cartItems: any[] = [];
	cartCount: number = 0;

	initializeCartBadge(): void {
		// Verificar si hay productos en localStorage
		try {
			const cartItems = JSON.parse(localStorage.getItem('cartItems') || '[]');
			this.cartItems = cartItems;
			this.updateCartCount();
			
			// Asegurarse de que existe el elemento de la insignia del carrito
			const cartIcon = document.querySelector('.cart-icon') || document.querySelector('.icon-cart');
			if (cartIcon && !document.querySelector('.cart-badge')) {
				const badge = document.createElement('span');
				badge.className = 'cart-badge';
				badge.textContent = this.cartCount.toString();
				badge.style.display = this.cartCount > 0 ? 'block' : 'none';
				cartIcon.appendChild(badge);
			}
		} catch (error) {
			console.error('Error al inicializar el contador del carrito:', error);
		}
	}

	updateCartCount(): void {
		this.cartCount = this.cartItems.length;
		// Actualizar el contador del carrito en el header
		const cartBadge = document.querySelector('.cart-badge') as HTMLElement;
		if (cartBadge) {
			cartBadge.textContent = this.cartCount.toString();
			cartBadge.style.display = this.cartCount > 0 ? 'block' : 'none';
		}
	}

	addToCart(product: any): void {
		this.updateCartCount();
		
		// Asegurarse de que existe el elemento de la insignia del carrito
		const cartIcon = document.querySelector('.cart-icon') || document.querySelector('.icon-cart');
		if (cartIcon && !document.querySelector('.cart-badge')) {
			const badge = document.createElement('span');
			badge.className = 'cart-badge';
			badge.textContent = this.cartCount.toString();
			badge.style.display = this.cartCount > 0 ? 'block' : 'none';
			cartIcon.appendChild(badge);
		}
	} catch (error) {
		console.error('Error al inicializar el contador del carrito:', error);
	}
}

updateCartCount(): void {
	this.cartCount = this.cartItems.length;
	// Actualizar el contador del carrito en el header
	const cartBadge = document.querySelector('.cart-badge') as HTMLElement;
	if (cartBadge) {
		cartBadge.textContent = this.cartCount.toString();
		cartBadge.style.display = this.cartCount > 0 ? 'block' : 'none';
	}
}

addToCart(product: any): void {
	this.cartItems.push(product);
	this.updateCartCount();
}

private formatMessageAsList(message: string): string {
	// Detectar productos en el mensaje
	const products = this.extractProductsFromMessage(message);
	
	// Eliminar la tabla HTML del mensaje original si existe
	let modifiedMessage = message;
	if (message.includes('<table>') && message.includes('</table>')) {
		modifiedMessage = message.replace(/<table>[\s\S]*?<\/table>/g, '');
	}
	
	// Procesar el mensaje sin la tabla HTML
	const lines = modifiedMessage.split('\n');
	
	// Arrays para almacenar las líneas formateadas
	const formattedListItems: string[] = [];
	let isOrderedList = false;
	
	// Si hay productos, crear tarjetas de producto
	if (products.length > 0) {
		const productCardsHtml = this.createProductCardsHtml(products);
		formattedListItems.push(productCardsHtml);
	}
	
	// Procesar el resto del mensaje
	lines.forEach((line) => {
		const trimmedLine = line.trim();
		// Saltarse las líneas que ya fueron procesadas como productos
		if (trimmedLine.startsWith('- nombre:') || 
			trimmedLine.startsWith('- precio:') || 
			trimmedLine.startsWith('url_imagen:') ||
			trimmedLine.startsWith('- url_imagen:') ||
			trimmedLine.includes('<img src=') ||
			trimmedLine.includes('Producto:') ||
			trimmedLine.includes('Precio:')) {
			return;
		}
		
		if (trimmedLine.startsWith('{"message":') || trimmedLine.startsWith(' {"message":')) {
			formattedListItems.push(`<li>Continuamos trabajando en tu solicitud...</li>`);
		}
		else if (trimmedLine.startsWith('- Imagen') || trimmedLine.startsWith('- URL') || 
			trimmedLine.startsWith('- **Imagen:**') || trimmedLine.startsWith('- **URL ')) {
			const imgMatch = trimmedLine.match(/https?:\/\/\S+/);
			if (imgMatch) {
				formattedListItems.push(`<li>
					<img src="${imgMatch[0]}" alt="" style="max-width: 50%;margin: auto;border-radius: 10px;" />
				</li>`);
			}
			return;
		}
		// Verificar si es una lista de puntos (• o -)
		else if (trimmedLine.startsWith('•') || trimmedLine.startsWith('-')) {
			formattedListItems.push(`<li>${trimmedLine}</li>`);
			isOrderedList = false;
		}
		// Verificar si es una lista numerada (inicia con "1.", "2.", etc.)
		else if (/^\d+\./.test(trimmedLine)) {
			formattedListItems.push(`<li>${trimmedLine}</li>`);
			isOrderedList = true;
		
		// Verificar si el mensaje contiene tabla HTML de productos
		if (message.includes('<table>') && message.includes('</table>')) {
			// Extraer productos de la tabla HTML
			return this.extractProductsFromTable(message);
		}

		// Formato anterior (texto plano con guiones)
		const lines = message.split('\n');
		let currentProduct: any = {};
		
		for (let i = 0; i < lines.length; i++) {
			const line = lines[i].trim();
			
			if (line.startsWith('- nombre:')) {
				// Si ya estábamos procesando un producto, guardarlo y comenzar uno nuevo
				if (Object.keys(currentProduct).length > 0) {
					products.push({...currentProduct});
					currentProduct = {};
				}
				
				currentProduct.name = line.replace('- nombre:', '').trim();
			} else if (line.startsWith('- precio:')) {
				currentProduct.price = line.replace('- precio:', '').trim();
			} else if (line.indexOf('url_imagen:') !== -1) {
				// Extraer la URL de la imagen (puede estar en diferentes formatos)
				const urlMatch = line.match(/url_imagen:\s*(https?:\/\/[^\s,]+)/i);
				if (urlMatch && urlMatch[1]) {
					currentProduct.imageUrl = urlMatch[1].trim();
				}
			}
			
			// Si hemos recopilado todos los datos del producto, agregarlo a la lista
			if (currentProduct.name && currentProduct.price && currentProduct.imageUrl) {
				products.push({...currentProduct});
				currentProduct = {};
			}
		}
		
		// Agregar el último producto si quedó pendiente
		if (Object.keys(currentProduct).length > 0 && currentProduct.name) {
			products.push(currentProduct);
		}
		
		return products;
	}
	
	private extractProductsFromTable(message: string): any[] {
		const products: any[] = [];
		
		// Extraer la parte del mensaje que contiene la tabla
		const tableMatch = message.match(/<table>([\s\S]*?)<\/table>/i);
		if (!tableMatch || !tableMatch[1]) return products;
		
		const tableContent = tableMatch[1];
		
		// Extraer filas de la tabla
		const rowRegex = /<tr>([\s\S]*?)<\/tr>/gi;
		let rowMatch;
		
		while ((rowMatch = rowRegex.exec(tableContent)) !== null) {
			const rowContent = rowMatch[1];
			
			// Extraer imagen
			const imgMatch = rowContent.match(/<img src="([^"]+)"/i);
			if (!imgMatch || !imgMatch[1]) continue;
			
			const imageUrl = imgMatch[1];
			
			// Extraer nombre del producto
			const productNameMatch = rowContent.match(/Producto:<\/p>\s*<p[^>]*>([^<]+)<\/p>/i);
			if (!productNameMatch || !productNameMatch[1]) continue;
			
			const productName = productNameMatch[1].trim();
			
			// Extraer precio
			const priceMatch = rowContent.match(/Precio:<\/p>\s*<p[^>]*>\$([^<]+)<\/p>/i);
			if (!priceMatch || !priceMatch[1]) continue;
			
			const price = '$' + priceMatch[1].trim();
			
			// Agregar producto a la lista
			products.push({
				name: productName,
				price: price,
				imageUrl: imageUrl
			});
		}
		
		return products;
	}
	
	private createProductCardsHtml(products: any[]): string {
		console.log(products);
		// Contenedor para todas las tarjetas de productos
		let html = `<div class="product-grid">`;
		
		// Crear tarjeta para cada producto
		products.forEach((product, index) => {
			html += `
		<div class="chat-item">
			<div class="chat-item__image"><img src="${product.imageUrl}" alt="${product.name}"></div>
			<div class="chat-item__details">
				<div>
					<div class="chat-item__brand-label">Marca</div>
					<div class="chat-item__brand">GENERIC</div>
					<div class="chat-item__name">${product.name}</div>
				</div>
				<div class="chat-item__controls">
					<div class="chat-item__quantity">
						<button class="quantity-btn quantity-btn--minus">−</button>
						<input type="text" value="3" class="quantity-input">
						<button class="quantity-btn quantity-btn--plus">+</button>
					</div>
					<div class="chat-item__price">${product.price}</div>
				</div>
			</div>
			<div class="chat-item__delete"><a-logo ng-reflect-src="icons/trash.svg"><figure><img title="logo" src="icons/trash.svg"></figure></a-logo></div>
			<button class="chat-item__add-btn">Agregar</button>
		</div>`;
		});
		
		html += `</div>
		<style>
			.chat-item {
				display: flex;
				width: 310px;
				height: 170px;
				margin: auto;
				position: relative;
				border-bottom: 1px solid #DBDBDB;
				padding: 15px 0 20PX 0;
			}
			.chat-item__image {
				width: 130px;
				height: 100px;
				object-fit: contain;
				background-color: #ffffff;
				display: flex;
				align-items: center;
				justify-content: center;
			}
			.chat-item__details {
				flex: 1;
				margin-left: 15px;
				display: flex;
				flex-direction: column;
				justify-content: space-between;
			}
			.chat-item__brand-label {
				font-size: 12px;
				color: #030302;
				font-weight: 400;
				margin-bottom: 5px;
			}
			.chat-item__brand {
				font-weight: 600;
				color: #FB1909;
				margin: 2px 0;
				font-size: 16px;
				margin-bottom: 10px;
			}
			.chat-item__name {
				font-size: 12px;
			}
			.chat-item__controls {
				display: flex;
				justify-content: space-between;
				margin-top: 10px;
				flex-direction: column;
				gap: 15px;
				align-items: start;
			}
			.chat-item__quantity {
				display: flex;
				align-items: center;
			}
			.chat-item__quantity .quantity-btn {
				background: none;
				border: 1px solid #DBDBDB;
				width: 24px;
				height: 24px;
				border-radius: 3px;
				display: flex;
				align-items: center;
				justify-content: center;
				cursor: pointer;
				background-color: #F6F7FC;
				color: #B6B6BA;
			}
			.chat-item__quantity input {
				width: 75px;
				height: 28px;
				border: 2px solid #E8E8ED;
				text-align: center;
				margin: 0 5px;
				border-radius: 5px;
			}
			.chat-item__price {
				font-weight: 400;
				font-size: 16px;
			}
			.chat-item__delete {
				position: absolute;
				top: 15px;
				right: 0;
				cursor: pointer;
				color: #FB1909;
			}
			.chat-item__add-btn {
				background-color: #FB1909;
				color: #ffffff;
				border: none;
				border-radius: 5px;
				padding: 5px 10px;
				cursor: pointer;
			}
		</style>
		<script>
			document.addEventListener('addToCart', function(e) {
				const product = e.detail;
				// Agregar al carrito
				const cartItems = JSON.parse(localStorage.getItem('cartItems') || '[]');
				cartItems.push(product);
				localStorage.setItem('cartItems', JSON.stringify(cartItems));
				
				// Actualizar contador del carrito
				const cartBadge = document.querySelector('.cart-badge');
				if (cartBadge) {
					cartBadge.textContent = cartItems.length;
					cartBadge.style.display = 'block';
				}
				
				// Notificar a Angular
				if (window.angularComponentRef) {
					window.angularComponentRef.addToCart(product);
				}
			});
		</script>`;
		
		return html;
	}
	
	
	

	private sanitizeMessage(message: string): SafeHtml {
		return this.sanitizer.bypassSecurityTrustHtml(message);
	}


	//Agente virtual depreciado por el uso de WebSocket
	async askingTheAgent(request: QuestionRequest): Promise<void> {
		this.isInputEmpty = false;
		this.isDisableInput = true;
		this.isTyping = true;

		try {
			const response = await this.agentService.getResponseAgentAsync(request);
			const answer = this.formatTextService.formatText(response.agent_answer);
			const answerLinkFormat = this.formatTextService.generateLinkHtml(answer);
			if (response.agent_answer) {
				this.chats.push({
					text: answerLinkFormat,
					isUser: false
				});
			}
			this.isDisableInput = false;
			this.isTyping = false;
			this.tryFocusInput();
			setTimeout(() => this.scrollToBottom(), 0);
		} catch (error) {
			console.error('Error al obtener la respuesta del agente:', error);

			this.isDisableInput = false;
			this.isTyping = false;
			this.chats.push({
				text: 'Hubo un error al procesar la solicitud. Inténtalo de nuevo.',
				isUser: false
			});
			this.tryFocusInput();
			setTimeout(() => this.scrollToBottom(), 0);
		}
	}
}
